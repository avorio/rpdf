// -*- C++ -*-

/*
   Copyright 2007 Deutsches Forschungszentrum fuer Kuenstliche Intelligenz 
   or its licensors, as applicable.
   
   You may not use this file except under the terms of the accompanying license.
   
   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License. You may
   obtain a copy of the License at http:  www.apache.org/licenses/LICENSE-2.0
   
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   
   Project: 
   File: 
   Purpose: 
   Responsible: tmb
   Reviewer: 
   Primary Repository: 
   Web Sites: www.iupr.org, www.dfki.de
*/

$#include "math.h"
$#include "colib.h"
$#include "imgio.h"
$#include "imglib.h"
$#include "ocr-layout-rast.h"
$//#include "layout-rules.h"
$//#include "ocr-recognize-page.h"
$#include "ocr-binarize-sauvola.h"
$#include "ocr-doc-clean.h"
$#include "ocr-deskew-rast.h"
$#include "ocr-text-image-seg.h"
$#include "langmod-aspell.h"
$#include "langmod-shortest-path.h"
$#include "segmentation.h"
$#include "ocr-utils.h"
$#include "ocr-segmentations.h"
$#include "bpnet.h"
$#include "mixtures.h"
$#include "bpnetmixtures.h"
$#include "ocrcomponents.h"
$#include "ocr-util.h"
$#include "regionextractor.h"
$#include "pages.h"
$#include "lines.h"
$#include "grouper.h"
$#include "grouping.h"
$#include "charlib.h"
$#include "recognized-page.h"
$#include "narray-io.h"
$#include "lattice.h"
$#include "beam-search.h"
$#include "classify-chars.h"
$#include "didegrade.h"
$#include "logger.h"
$#include "idmap.h"
$//#include "ocr-recognize-line.h"
$//#include "ocr-recognize-page.h"
$#ifdef HAVE_FST
$#include "fstutil.h"
$#include "fstbuilder.h"
$#include "fstmodels.h"
$#endif

$using namespace ocropus;
$using namespace colib;
$using namespace imglib;

struct point {
    int x;
    int y;
    point();
    point(int x,int y);
};

struct rectangle {
    int x0;
    int y0;
    int x1;
    int y1;
    rectangle();
    rectangle(int x0,int y0,int x1,int y1);
    bool empty();
    int width();
    int height();
    void include(int x,int y);
    bool contains(int x,int y);
    void intersect(rectangle other);
    void include(rectangle other);
    rectangle intersection(rectangle other);
    rectangle inclusion(rectangle other);
    rectangle grow(int offset);
};

$typedef narray<rectangle> rectanglearray;

// ocr-utils

void make_line_segmentation_black(intarray &image);
void make_line_segmentation_white(intarray &image);
void make_page_segmentation_black(intarray &image);
void make_page_segmentation_white(intarray &image);

// OCRopus objects

class idmap {
    idmap();
    void segments_of_id(intarray &result,int id);
    void ids_of_segment(intarray &result,int segment);
    void associate(int id, int segment);
    void clear();
};

struct IComponent {
    virtual ~IComponent() {}
    virtual const char *description() = 0;
    virtual void set(const char *,const char *);
    virtual void set(const char *,double);
};

struct ICleanupGray : IComponent {
    virtual void cleanup(bytearray &out,bytearray &in) = 0;
};

struct ICleanupBinary : IComponent {
    virtual void cleanup(bytearray &out,bytearray &in) = 0;
};

struct ISegmentPage : IComponent {
    virtual void segment(intarray &out,bytearray &in) = 0;
};

struct ISegmentLine : IComponent {
    virtual void charseg(intarray &out,bytearray &in) = 0;
};

struct IBinarize : IComponent {
    virtual void binarize(bytearray &out,bytearray &in) = 0;
    virtual void binarize(bytearray &out,floatarray &in) = 0;
};

struct IGenericFst : IComponent {
    void clear();
    int newState();
    void addTransition(int from,int to,int output,float cost,int input);
    void setStart(int node);
    void setAccept(int node,float f=0.0);
    int special(const char *s);
    void bestpath(nustring &result);
    void setString(nustring &result,floatarray &costs,intarray &ids);
    virtual int nStates() = 0;
    virtual int getStart() = 0;
    virtual float getAcceptCost(int node) = 0;
    virtual void arcs(intarray &ids,
                      intarray &targets,
                      intarray &outputs,
                      floatarray &costs, 
                      int from) = 0;
};

struct ICharacterClassifier : IComponent {
    // classify a character without any information about position on the line; this
    // may throw an exception if it's not implemented
    virtual void set(bytearray &input_image) = 0;
    // classify a character with information about position on the line; this may
    // throw an exception if it's not implemented
    virtual void set(bytearray &image,int base_y, int xheight_y, int descender_y, int ascender_y) = 0;
    // number of classes returned
    virtual int length() = 0;
    // UTF-8 encoded character or character string; note that some classifiers may return multiple characters
    // per class
    virtual void cls(nustring &result, int i) = 0;
    // cost value for this classification; lower costs = better
    virtual float cost(int i) = 0;
    // train a character (commonly, this only stores data in the model; training is via an external program)
    virtual void startTraining(const char *type="adaptation");
    // this may be also train on ligatures (if supported),
    // that's why `characters' is a nustring.
    virtual void addTrainingChar(bytearray &input_image,nustring &characters) 
        { throw "unimplemented"; }
    // train a character
    virtual void addTrainingChar(bytearray &image,int base_y, int xheight_y, int descender_y,
            int ascender_y,nustring &characters) { throw "unimplemented"; }
    // train a character in context (think about this some more)
    virtual void addTrainingChar(bytearray &image,bytearray &mask,nustring &characters)
            { throw "unimplemented"; }
    virtual void finishTraining() { throw "unimplemented"; }
    // save a trained model to the stream
    virtual void save(FILE *stream) { throw "unimplemented"; }
    void save(const char *path);
    void load(const char *path);

    // load a trained model from the stream
    virtual void load(FILE *stream) { throw "unimplemented"; }
    // convenience function for getting the best output (useful for debugging)
    virtual void best(nustring &result) {
        int mi = -1;
        float mc = 1e30;
        for(int i=0;i<length();i++) {
            if(cost(i)<mc) {
                mi = i;
                mc = cost(i);
            }
        }
        if(mi>=0)
            cls(result, mi);
        else
            result.clear();
    }
    // destructor
    virtual ~ICharacterClassifier() {}
};


struct IRecognizeLine : IComponent {
    virtual void recognizeLine(IGenericFst &result,bytearray &image) = 0;
    // train a text_line
    // cseg should be either empty or a segmentation into individual characters (different implementation
    // may have different requirements)
    // Usage is: call addTrainingLine with training data, then call finishTraining 
    // The state of the object is undefined between calling addTrainingLine and finishTraining, and it is
    // an error to call recognizeLine before finishTraining completes.  This allows both batch
    // and incemental training.
    // "adaptation" means temporary adaptation of the classifier
    // to all the lines between startTraining and finishTraining
    // other types of training are recognizer-dependent
    virtual void startTraining(const char *type="adaptation") { throw "unimplemented"; }
    // NB: you might train on length 1 strings for single character training
    // and might train on words if line alignment is not working
    // well for some training data
    virtual void addTrainingLine(bytearray &image,nustring &transcription) { throw "unimplemented"; }
    // eventually?
    // virtual void addTrainingLine(bytearray &image,IGenericFst &transcription) { throw "unimplemented"; }
    virtual void finishTraining() { throw "unimplemented"; }
    // save a trained model to the stream
    virtual void save(FILE *stream) { throw "unimplemented"; }
    // load a trained model from the stream
    virtual void load(FILE *stream) { throw "unimplemented"; }
    // destructor
    virtual ~IRecognizeLine() {}
    // this is a weird, optional method that exposes character segmentation for those line recognizers that have it
    // segmentation contains colored pixels, and a transition in
    // the transducer of the form * --- 1/eps --> * --- 2/a --> *
    // means that pixels with color 1 and 2 together form the
    // letter "a"
    virtual void recognizeLine(intarray &segmentation,IGenericFst &result,bytearray &image) { throw "unimplemented"; }
    virtual void align(nustring &chars,intarray &result,floatarray &costs, bytearray &image,IGenericFst &transcription) { throw "unimplemented"; }
};


struct IBestPath {
    virtual void bestpath(nustring &result,floatarray &costs,intarray &ids,intarray &states) = 0;
};
struct ISearchableFst : IGenericFst, IBestPath {};
ISearchableFst *make_ShortestPathSearchableFst();

struct IDict {
    virtual bool lookup(nustring &correction, nustring &word) = 0;
    virtual ~IDict() {}
};

IDict *make_WordList(const char *path);
IDict *make_Aspell();
IBestPath *make_DictBestPath(IBestPath *l, IDict *d);


void binarize_by_range(bytearray &image,float fraction=0.5);
void binarize_by_range(bytearray &out,floatarray &in,float fraction=0.5);
IBinarize *make_BinarizeBySauvola();
IBinarize *make_BinarizeByRange();

ICleanupBinary *make_DeskewPageByRAST();
ICleanupBinary *make_TextImageSeg();
ICleanupBinary *make_DocClean();

ISegmentPage *make_SegmentPageBySmear();
ISegmentPage *make_SegmentPageBy1CP();
ISegmentPage *make_SegmentPageByRAST();

ISegmentLine *make_SegmentLineByProjection();
ISegmentLine *make_SegmentLineByCCS();
ISegmentLine *make_ConnectedComponentSegmenter();
ISegmentLine *make_CurvedCutSegmenter();
ISegmentLine *make_SkelSegmenter();

struct RegionExtractor {
    RegionExtractor();
    void setImage(intarray &image);
    void setImageMasked(intarray &image,int mask=0xffffff,int lo=1,int hi=999999999);
    void setPageColumns(intarray &image);
    void setPageParagraphs(intarray &image);
    void setPageLines(intarray &image);
    int length();
    rectangle bbox(int i);
    void bounds(int i,int *x0=0,int *y0=0,int *x1=0,int *y1=0);
    int x0(int i);
    int y0(int i);
    int x1(int i);
    int y1(int i);
    void extract(bytearray &output,bytearray &input,int index,int margin=0);
    void extract(intarray &output,bytearray &input,int index,int margin=0);
    void extract(intarray &output,intarray &input,int index,int margin=0);
    void extract(floatarray &output,floatarray &input,int index,int margin=0);
    void extract(floatarray &output,bytearray &input,int index,int margin=0);
    void extract(floatarray &output,intarray &input,int index,int margin=0);
    void mask(bytearray &output,int index,int margin=0);
    void mask(intarray &output,int index,int margin=0);
    void mask(floatarray &output,int index,int margin=0);
};

void debug_array(bytearray &);
void debug_array(intarray &);
void debug_array(floatarray &);

void check_line_segmentation(intarray &cseg,bool allow_zero=true,bool allow_gaps=false,bool allow_lzero=true);
void check_page_segmentation(intarray &cseg,bool allow_zero=true);

void sort_by_xcenter(intarray &);

struct IGrouper {
    int maxrange;
    int maxdist;
    void setSegmentation(intarray &segmentation);
    int length();
    void getMask(rectangle &r,bytearray &mask,int index,int margin);
    rectangle boundingBox(int index);
    void extract(bytearray &out,bytearray &mask,bytearray &source,int index,int grow=0);
    void extract(floatarray &out,bytearray &mask,floatarray &source,int index,int grow=0);
    void extract(bytearray &out,bytearray &source,byte dflt,int index,int grow=0);
    void extract(floatarray &out,floatarray &source,float dflt,int index,int grow=0);
    void setClass(int index,int cls,float cost);
};

IGrouper *make_StandardGrouper();

struct Pages {
    Pages();
    void clear();
    void addFile(const char *file);
    void parseSpec(const char *spec);
    void wantGray(bool flag);
    void wantColor(bool flag);
    void setAutoInvert(bool flag);
    void setBinarizer(IBinarize *arg);
    int length();
    void getPage(int index);
    bool nextPage();
    void rewind();
    void loadImage();
    const char *getFileName();
    bool hasGray();
    bool hasColor();
    void getBinary(bytearray &dst);
    void getGray(bytearray &dst);
    void getColor(intarray &dst);
};

/*
struct ILines : IComponent {
    virtual int pagesCount();
    virtual void processPage(int index);
    virtual double getTotalElapsedTime();
    virtual double getCurrentPageElapsedTime();
    virtual int linesCount();
    virtual void line(bytearray &result_image,
                      bytearray &result_mask, 
                      int index);
    virtual int columnIndex(int line);
    virtual int paragraphIndex(int line);
    
    void grayPage(bytearray &);
    void binaryPage(bytearray &);
    void segmentation(intarray &r);
    
    virtual int pageWidth();
    virtual int pageHeight();
    virtual const char *pageDescription();

    virtual rectangle bbox(int index);
    virtual void setBinarizer     (IBinarize      *);
    virtual void setDeskewer      (ICleanupGray   *);
    virtual void addCleanupGray   (ICleanupGray   *);
    virtual void addCleanupBinary (ICleanupBinary *);
    virtual void setPageSegmenter (ISegmentPage   *);
};

ILines *make_Lines(Pages *);
ILines *make_Lines(const char *page_specs);

*/

// we still need it for interfacing the Tesseract in blockwise mode...
struct RecognizedPage {
    RecognizedPage();
    ~RecognizedPage();
    void setLinesCount(int n);
    int linesCount();
    void setText(nustring &s, int index);
    void text(nustring &s, int index);
    void setCosts(floatarray &c, int index);
    void costs(floatarray &c, int index);
    rectangle bbox(int index);
    void setBbox(rectangle bbox, int index);
    int width();
    int height();
    void setWidth(int width);
    void setHeight(int height);
    const char *description();
    void setDescription(const char *s);
    const char *timeReport();
    void setTimeReport(const char *s);
};

/*
void recognize(RecognizedPage &result,
               ILines &lines,
               ILineOCR &ocr,
               IGenericFst &fst,
               IBestPath &bestpath,
               int pageno = 0);
$ IBestPath &as_IBestPath(ISearchableFst &s) {
$    return s;
$ }
IBestPath &as_IBestPath(ISearchableFst &s);

/// 1-pass recognition.
void recognize(RecognizedPage &result,
               ILines &lines,
               ISegmentLine &lineseg,
               IRecognizeLine &rec,
               IGenericFst &fst,
               IBestPath &bestpath,
               float adaption_threshold,
               int pageno = 0);

/// 1-pass recognition with adaptation.
void recognize(RecognizedPage &result,
               ILines &lines,
               ISegmentLine &lineseg,
               IRecognizeLine &rec,
               IGenericFst &fst,
               IBestPath &bestpath,
               ITrainChars &trainable,
               float adaption_threshold,
               int pageno = 0);

/// 2-pass recognition.
void recognize(RecognizedPage &result,
               ILines &lines,
               ISegmentLine &lineseg,
               IRecognizeLine &pass1,
               IGenericFst &fst1,
               IBestPath &bestpath1,
               ITrainChars &trainable,
               IRecognizeLine &pass2,
               IGenericFst &fst2,
               IBestPath &bestpath2,
               float adaption_threshold,
               int pageno = 0);
*/




#define M_PI M_PI

/*
bool utf8_encode(bytearray &utf8, intarray &lengths, int unicode_char);
bool utf8_encode(bytearray &utf8, intarray &lengths, nustring &text);
bool utf8_encode(bytearray &utf8, int unicode_char);
bool utf8_encode(bytearray &utf8, nustring &text);
bool utf8_decode(int &result, int &length, bytearray &utf8, int offset);
bool utf8_decode(nustring &text, intarray &lengths, bytearray &utf8);
bool utf8_decode(nustring &text, bytearray &utf8);
*/

$ void str2array(bytearray &out,const char *s) {
$     int n = strlen(s);
$     out.resize(n);
$     for(int i=0;i<n;i++) out[i] = s[i];
$ }
$ char *array2str(bytearray &buf) {
$     char *result = (char*)malloc(buf.length()+1);
$     for(int i=0;i<buf.length();i++) result[i] = buf[i];
$     result[buf.length()] = 0;
$     return result;
$ }
void str2array(bytearray &out,const char *s);
char *array2str(bytearray &buf);

$#include "bpnetline.h"
$#include "glinerec.h"

$using namespace ocropus;
//ISegmentedLineOCR *make_BpnetLineOCR(const char *path);
IRecognizeLine *make_NewBpnetLineOCR(const char *path);
IRecognizeLine *make_NewGroupingLineOCR(ICharacterClassifier *classifier, ISegmentLine *segmenter, bool use_line_info = true);
IRecognizeLine *make_GLineRec();

void replace_values(bytearray &a,byte,byte);
void replace_values(intarray &a,int,int);
void replace_values(floatarray &a,float,float);
void evaluate_segmentation(int &nover,int &nunder,int &nmis,intarray &model_raw,intarray &image_raw,float tolerance);
void ocr_result_to_charseg(intarray &cseg,idmap &map,intarray &ids,intarray &segmentation,bool map_all=true);
void ocr_bboxes_to_charseg(intarray &cseg,rectanglearray &bboxes,intarray &segmentation);

int pseg_pixel(int column,int paragraph,int line);
int pseg_pixel(int column,int line);
int pseg_column(int pixel);
int pseg_paragraph(int pixel);
int pseg_line(int pixel);
int pseg_pline(int pixel);
int cseg_pixel(int chr);
void pseg_columns(intarray &a);
void pseg_plines(intarray &a);

$int hex(const char *s) { int v; sscanf(s,"%x",&v); return v; }
int hex(const char *s);

intarray *as_intarray(const char *s);
intarray *as_intarray(bytearray &a);
intarray *as_intarray(nustring &a);
const char *as_string(bytearray &a);
const char *as_string(nustring &a);
const char *as_string(intarray &a);

intarray *utf32(const char *s);
const char *utf8(intarray &a);

struct ICharacter {
    /// Returns a reference to the current image.
    /// Probably should be deprecated in favor of get_image().
    bytearray &image();
    /// This should become the replacement for image().
    inline void get_image(colib::bytearray &result);
    int code();
    int xHeight();
    int baseline();
    int descender();
    int ascender();
    const char *info();
};

struct ICharacterLibrary : IComponent {
    int sectionsCount();

    void switchToSection(int no);
    int currentSectionIndex();

    /// Returns the number of characters in the current section.
    /// Sections cannot be empty.
    int charactersCount();

    /// The returned reference is only valid till next switching.
    ICharacter &character(int index);
};

/// Make a slice of existing library. Two indices given here are indices of sections.
ICharacterLibrary *make_slice_charlib(ICharacterLibrary &charlib, int from_incl, int upto_excl);

/// Join some characters like O and 0. This is for evaluation only.
ICharacterLibrary *make_filter_charlib(ICharacterLibrary &charlib);

/// Make a CharacterLibrary that reads grid files.
ICharacterLibrary *make_grid_charlib(const char *directory, bool use_garbage = true);

/// Make a CharacterLibrary from UW3 character data. The given directory should contain
/// GROUND and IMAGEBIN subdirectories. There are two such directories in UW3:
/// /ENGLISH/CHAR_TRU/SYNTHET and /ENGLISH/CHAR_TRU/REAL.
ICharacterLibrary *make_uw3_charlib(const char *directory, const char *picture_suffix);

/// Make a charlib whereby directory is the path to a file listing screen ocr pics.
/// list file similar to /data/datasets/screen-text/extracted-screen-chars/extracted-images/screen-chars.txt
ICharacterLibrary *make_screenocr_charlib(const char *directory);

/// Make a CharacterLibrary from a file containing "<character> <png file name>" pairs.
ICharacterLibrary *make_pnglist_charlib(const char *list);

/// Make a CharacterLibrary from a ocropus-generated pair of files.
ICharacterLibrary *make_ocropus_charlib(const char *prefix);

/// Make a CharacterLibrary from a forced-alignment-generated pair of files.
ICharacterLibrary *make_SegmentationCharlib(const char *file_list_path,
                                             bool produce_garbage = false);

/// Make a CharacterLibrary from a forced-alignment-generated pair of files.
ICharacterLibrary *make_SegmentationCharlib(const char *image_path,
                                            const char *text_path,
                                            bool produce_garbage);


// void dump_charlib(const char *path, ICharacterLibrary &);
void parse_vector(intarray &, const char *);



const char *get_version_string();
void set_version_string(const char *);
$ const char *hardcoded_version_string();
const char *hardcoded_version_string();




/*void detect_headlines(RecognizedPage &, ILines &);
void detect_paragraphs(RecognizedPage &, ILines &);*/

void concat_segmentation(intarray &dst, intarray &src, int x, int y);
void remove_small_components(intarray &bimage,int mw,int mh);
void remove_marginal_components(intarray &bimage,int x0,int y0,int x1,int y1);
void remove_small_components(bytearray &bimage,int mw,int mh);
void remove_marginal_components(bytearray &bimage,int x0,int y0,int x1,int y1);
void runlength_histogram(floatarray &hist, bytearray &img);
int find_median(floatarray &);
void make_background_white(bytearray &);
class Classifier {
    virtual ~Classifier() {}
    virtual void param(const char *name,double value) = 0;
    virtual void add(floatarray &v,int c) = 0;
    virtual void score(floatarray &result,floatarray &v) = 0;
    virtual void start_training() = 0;
    virtual void start_classifying() = 0;
    virtual void seal() = 0;
    virtual void save(FILE *stream) = 0;
    virtual void load(FILE *stream) = 0;
    void save(const char *path);
    void load(const char *path);
};

class Density {
    virtual ~Density() {}
    virtual void param(const char *name,double value) = 0;
    virtual void add(floatarray &v) = 0;
    virtual double logp(floatarray &v) = 0;
    virtual void start_training() = 0;
    virtual void start_classifying() = 0;
    virtual void seal() = 0;
    void save(const char *path);
    void load(const char *path);
};
ICharacterClassifier *make_AdaptClassifier(Classifier *, bool output_garbage = false);
Classifier *make_BpnetClassifier();
Classifier *make_MixturesClassifier();
Classifier *make_BpnetMixturesClassifier();
Classifier *make_BpnetMixturesClassifier(const char*, const char*);
void set_resource_path(const char *path);
void find_and_load_ICharacterClassifier(ICharacterClassifier &,
                                        const char *resource);
void find_and_load_IRecognizeLine(IRecognizeLine &i,
                                  const char *resource);
void extract_segment(bytearray &result, intarray &image, int n);


IGenericFst *make_StandardFst();

void beam_search(intarray &ids,
                 intarray &vertices,
                 intarray &outputs,
                 floatarray &costs,
                 IGenericFst &graph,
                 int beam_width = 10);

/// Degrade a grayscale text image by applying Baird's degradation model.
void degrade(bytearray &image,
             double jitter_mean = .2,
             double jitter_sigma = .1,
             double sensitivity_mean = .125,
             double sensitivity_sigma = .04,
             double threshold_mean = .4,
             double threshold_sigma = .04);

class Logger {
    bool enabled;

    /// \brief 
    /// Construct a logger with a given name
    /// and decide whether it's enabled or not.
    Logger(const char *name);

    /// Recolor a segmentation and log it.
    void recolor(const char *description, colib::intarray &);

    /// Just log the message.
    void log(const char *message);
    
    /// Log a boolean value.
    void log(const char *message, bool);
    
    /// Log an integer value.
    void log(const char *message, int);
    
    /// Log a double value.
    void log(const char *message, double);

    /// Log a string.
    void log(const char *description, const char *);
    
    /// \brief Log a grayscale image.
    ///
    /// If the image is not 2-dimensional,
    /// it will be written as text.
    void log(const char *description, bytearray &);

    /// \brief Log a color image.
    ///
    /// If the image is not 2-dimensional,
    /// it will be written as text.
    void log(const char *description, intarray &);

    /// \brief Log an array of floats.
    ///
    void log(const char *description, floatarray &);

    /// Log a nuchar value.
    void log(const char *description, nuchar);
    
    /// Log a nustring value, decoding it to UTF-8.
    void log(const char *description, nustring &);

    /// Log a rectangle.
    void log(const char *description, rectangle &);

    // not good for Lua binding - shadows arrays
    //void log(const char *description, void *);

    /// Draw 4 lines on the line image and log it.
    void log(const char *description, bytearray &line_image,
         int baseline_y, int xheight_y, int ascender_y, int descender_y);

    /// Get a bestpath and log it.
    void log(const char *description, IGenericFst &);

    /// Increase indentation level in the log.
    void indent();
    
    /// Decrease indentation level in the log.
    void dedent();
};

void set_logger_directory(const char *);
void visualize_segmentation_by_RAST(intarray &result, bytearray &in_not_inverted);

