// -*- C++ -*-

// FIXME there are lots of functions still missing here...

/*
   Copyright 2007 Deutsches Forschungszentrum fuer Kuenstliche Intelligenz 
   or its licensors, as applicable.
   
   You may not use this file except under the terms of the accompanying license.
   
   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License. You may
   obtain a copy of the License at http:  www.apache.org/licenses/LICENSE-2.0
   
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   
   Project: 
   File: 
   Purpose: 
   Responsible: tmb
   Reviewer: 
   Primary Repository: 
   Web Sites: www.iupr.org, www.dfki.de
*/

$#include "colib.h"
$ extern "C" {
$#include "leptonica/allheaders.h"
$#include "leptonica/morph.h"
$ using namespace colib;
$ extern int count_pixRasterops;
$ }

module lepton {

    extern int count_pixRasterops;

    enum {
        L_HORIZ      = 1,
        L_VERT       = 2
    };

    enum {
        L_MORPH_DILATE    = 1,
        L_MORPH_ERODE     = 2,
        L_MORPH_OPEN      = 3,
        L_MORPH_CLOSE     = 4
    };

    enum {
        L_RUN_OFF = 0,
        L_RUN_ON  = 1
    };


#define IFF_UNKNOWN 0
#define IFF_BMP 1
#define IFF_JFIF_JPEG 2
#define IFF_PNG 3
#define IFF_TIFF 4
#define IFF_TIFF_PACKBITS 5
#define IFF_TIFF_G3 6
#define IFF_TIFF_G4 7
#define IFF_PNM 8
#define IFF_PS 9
#define IFF_DEFAULT 10
#define BMP_ID 0x4d42
#define TIFF_BIGEND_ID 0x4d4d
#define TIFF_LITTLEEND_ID 0x4949      
#define L_HINT_GRAY 1

PIX * pixCreate( int width, int height, int depth );
PIX * pixCreateTemplate( PIX *pixs );
PIX * pixClone( PIX *pixs );
void pixDestroy( PIX **ppix );
void pixFree( PIX *pix );
PIX * pixCopy( PIX *pixd, PIX *pixs );
int pixCopyColormap( PIX *pixd, PIX *pixs );
int pixSizesEqual( PIX *pix1, PIX *pix2 );
int pixGetWidth( PIX *pix );
int pixSetWidth( PIX *pix, int width );
int pixGetHeight( PIX *pix );
int pixSetHeight( PIX *pix, int height );
int pixGetDepth( PIX *pix );
int pixSetDepth( PIX *pix, int depth );
int pixGetDimensions( PIX *pix, int *pw, int *ph, int *pd );
int pixGetWpl( PIX *pix );
int pixSetWpl( PIX *pix, int wpl );
int pixGetRefcount( PIX *pix );
int pixChangeRefcount( PIX *pix, int delta );
unsigned int pixGetXRes( PIX *pix );
unsigned int pixGetYRes( PIX *pix );
int pixSetXRes( PIX *pix, unsigned int res );
int pixCopyResolution( PIX *pixd, PIX *pixs );
int pixScaleResolution( PIX *pix, float xscale, float yscale );
int pixSetYRes( PIX *pix, unsigned int res );
int pixGetInputFormat( PIX *pix );
int pixSetInputFormat( PIX *pix, int informat );
int pixCopyInputFormat( PIX *pixd, PIX *pixs );
char * pixGetText( PIX *pix );
int pixSetText( PIX *pix, const char *textstring );
int pixAddText( PIX *pix, const char *textstring );
int pixCopyText( PIX *pixd, PIX *pixs );
int pixDestroyColormap( PIX *pix );
PIXCMAP * pixGetColormap( PIX *pix );
int pixSetColormap( PIX *pix, PIXCMAP *colormap );
/* 
unsigned int * pixGetData( PIX *pix );
int pixSetData( PIX *pix, unsigned int *data );
 */
int pixPrintStreamInfo( FILE *fp, PIX *pix, const char *text );
int pixGetPixel( PIX *pix, int x, int y, unsigned int *pval );
int pixSetPixel( PIX *pix, int x, int y, unsigned int val );
int pixClearPixel( PIX *pix, int x, int y );
int pixFlipPixel( PIX *pix, int x, int y );
void setPixelLow( unsigned int *line, int x, int depth, unsigned int val );
int pixClearAll( PIX *pix );
int pixSetAll( PIX *pix );
int pixSetAllArbitrary( PIX *pix, unsigned int val );
int pixSetPadBits( PIX *pix, int val );
int pixSetPadBitsBand( PIX *pix, int by, int bh, int val );
int pixSetOrClearBorder( PIX *pixs, int left, int right, int top, int bot, int op );
int pixSetBorderVal( PIX *pixs, int left, int right, int top, int bot, unsigned int val );
PIX * pixAddBorder( PIX *pixs, int npix, unsigned int val );
PIX * pixRemoveBorder( PIX *pixs, int npix );
PIX * pixAddBorderGeneral( PIX *pixs, int left, int right, int top, int bot, unsigned int val );
PIX * pixAddMirroredBorder( PIX *pixs, int left, int right, int top, int bot );
PIX * pixRemoveBorderGeneral( PIX *pixs, int left, int right, int top, int bot );
PIX * pixCreateRGBImage( PIX *pixr, PIX *pixg, PIX *pixb );
PIX * pixGetRGBComponent( PIX *pixs, int color );
int pixSetRGBComponent( PIX *pixd, PIX *pixs, int color );
int composeRGBPixel( int rval, int gval, int bval, unsigned int *ppixel );
int pixGetRGBLine( PIX *pixs, int row, unsigned char *bufr, unsigned char *bufg, unsigned char *bufb );
PIX * pixEndianByteSwapNew( PIX *pixs );
int pixEndianByteSwap( PIX *pixs );
PIX * pixEndianTwoByteSwapNew( PIX *pixs );
int pixEndianTwoByteSwap( PIX *pixs );
int pixSetMasked( PIX *pixd, PIX *pixm, unsigned int val );
int pixSetMaskedGeneral( PIX *pixd, PIX *pixm, unsigned int val, int x, int y );
int pixCombineMasked( PIX *pixd, PIX *pixs, PIX *pixm );
int pixPaintThroughMask( PIX *pixd, PIX *pixm, int x, int y, unsigned int val );
PIX * pixInvert( PIX *pixd, PIX *pixs );
PIX * pixOr( PIX *pixd, PIX *pixs1, PIX *pixs2 );
PIX * pixAnd( PIX *pixd, PIX *pixs1, PIX *pixs2 );
PIX * pixXor( PIX *pixd, PIX *pixs1, PIX *pixs2 );
PIX * pixSubtract( PIX *pixd, PIX *pixs1, PIX *pixs2 );
int pixZero( PIX *pix, int *pempty );
int pixCountPixels( PIX *pix, int *pcount, int *tab8 );

PIX * pixConvertRGBToLuminance( PIX *pixs );
PIX * pixConvertRGBToGray( PIX *pixs, float rwt, float gwt, float bwt );
PIX * pixConvertRGBToGrayFast( PIX *pixs );
PIX * pixConvertGrayToColormap( PIX *pixs );
PIX * pixConvertGrayToColormap8( PIX *pixs, int mindepth );
PIX * pixConvertRGBToColormap( PIX *pixs, int level, int *pnerrors );
PIX * pixConvert16To8( PIX *pixs, int whichbyte );
PIX * pixConvertGrayToFalseColor( PIX *pixs, float gamma );
PIX * pixUnpackBinary( PIX *pixs, int depth, int invert );
PIX * pixConvert1To16( PIX *pixd, PIX *pixs, l_uint16 val0, l_uint16 val1 );
PIX * pixConvert1To32( PIX *pixd, PIX *pixs, l_uint32 val0, l_uint32 val1 );
PIX * pixConvert1To2Cmap( PIX *pixs );
PIX * pixConvert1To2( PIX *pixd, PIX *pixs, int val0, int val1 );
PIX * pixConvert1To4Cmap( PIX *pixs );
PIX * pixConvert1To4( PIX *pixd, PIX *pixs, int val0, int val1 );
PIX * pixConvert1To8( PIX *pixd, PIX *pixs, l_uint8 val0, l_uint8 val1 );
PIX * pixConvert2To8( PIX *pixs, l_uint8 val0, l_uint8 val1, l_uint8 val2, l_uint8 val3, int cmapflag );
PIX * pixConvert4To8( PIX *pixs, int cmapflag );
PIX * pixConvertTo1( PIX *pixs, int threshold );
PIX * pixConvertTo8( PIX *pixs, int cmapflag );
PIX * pixConvertTo32( PIX *pixs );
PIX * pixConvert8To32( PIX *pixs );
PIX * pixConvertLossless( PIX *pixs, int d );
PIX * pixConvertForPSWrap( PIX *pixs );
PIX * pixConvertRGBToHSV( PIX *pixd, PIX *pixs );
PIX * pixConvertHSVToRGB( PIX *pixd, PIX *pixs );

PIX * pixReadStreamBmp( FILE *fp );
int pixWriteStreamBmp( FILE *fp, PIX *pix );
PIX * pixReadJpeg( const char *filename, int cmflag, int reduction, int *pnwarn );
PIX * pixReadStreamJpeg( FILE *fp, int cmflag, int reduction, int *pnwarn, int hint );
int pixWriteJpeg( const char *filename, PIX *pix, int quality, int progressive );
int pixWriteStreamJpeg( FILE *fp, PIX *pix, int quality, int progressive );
PIX * pixReadStreamPng( FILE *fp );
int pixWritePng( const char *filename, PIX *pix, float gamma );
int pixWriteStreamPng( FILE *fp, PIX *pix, float gamma );
PIX * pixReadStreamPnm( FILE *fp );
int pixWriteStreamPnm( FILE *fp, PIX *pix );
int pixWriteStreamAsciiPnm( FILE *fp, PIX *pix );
PIX * pixRead( const char *filename );
PIX * pixReadWithHint( const char *filename, int hint );
PIX * pixReadStream( FILE *fp, int hint );
PIX * pixReadTiff( const char *filename, int n );
PIX * pixReadStreamTiff( FILE *fp, int n );
int pixWriteTiff( const char *filename, PIX *pix, int comptype, const char *modestring );
int pixWriteStreamTiff( FILE *fp, PIX *pix, int comptype );
int tiffGetCount( FILE *fp, int *pn );
int pixWrite( const char *filename, PIX *pix, int format );
int pixWriteStream( FILE *fp, PIX *pix, int format );
int pixChooseOutputFormat( PIX *pix );

PIX * pixDilate ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixErode ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixHMT ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixOpen ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixClose ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixCloseSafe ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixOpenGeneralized ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixCloseGeneralized ( PIX *pixd, PIX *pixs, SEL *sel );
PIX * pixDilateBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixErodeBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixOpenBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixCloseBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixCloseSafeBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixDilateCompBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixErodeCompBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixOpenCompBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixCloseCompBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );
PIX * pixCloseSafeCompBrick ( PIX *pixd, PIX *pixs, int hsize, int vsize );

PIX * pixRenderContours( PIX *pixs, int startval, int incr, int outdepth );
PIX * pixErodeGray( PIX *pixs, int hsize, int vsize );
PIX * pixDilateGray( PIX *pixs, int hsize, int vsize );
PIX * pixOpenGray( PIX *pixs, int hsize, int vsize );
PIX * pixCloseGray( PIX *pixs, int hsize, int vsize );
PIX * pixDitherToBinary( PIX *pixs );
PIX * pixDitherToBinarySpec( PIX *pixs, int lowerclip, int upperclip );
PIX * pixThresholdToBinary( PIX *pixs, int thresh );
PIX * pixDitherToBinaryLUT( PIX *pixs, int lowerclip, int upperclip );

PIX * pixDeskewLocal ( PIX *pixs, int nslices, int redsweep, int redsearch, float sweeprange, float sweepdelta, float minbsdelta );
PIX * pixFindSkewAndDeskew ( PIX *pixs, int redsearch, float *pangle, float *pconf );
int pixFindSkew ( PIX *pixs, float *pangle, float *pconf );
int pixFindSkewSweep ( PIX *pixs, float *pangle, int reduction, float sweeprange, float sweepdelta );
int pixFindSkewSweepAndSearch ( PIX *pixs, float *pangle, float *pconf,
                                int redsweep, int redsearch, float sweeprange,
                                float sweepdelta, float minbsdelta );
int pixFindSkewSweepAndSearchScore ( PIX *pixs, float *pangle, float *pconf,
                                     float *endscore, int redsweep, int redsearch,
                                     float sweepcenter, float sweeprange, float sweepdelta, float minbsdelta );

PIX * pixEmbedForRotation ( PIX *pixs, float angle, int incolor, int width, int height );
PIX * pixRotateAM ( PIX *pixs, float angle, int incolor );
PIX * pixRotateAMColor ( PIX *pixs, float angle, l_uint32 colorval );
PIX * pixRotateAMGray ( PIX *pixs, float angle, int grayval );
PIX * pixRotateAMCorner ( PIX *pixs, float angle, int incolor );
PIX * pixRotateAMColorCorner ( PIX *pixs, float angle, int grayval );
PIX * pixRotateAMGrayCorner ( PIX *pixs, float angle, int grayval );
PIX * pixRotateAMColorFast ( PIX *pixs, float angle, int grayval );

PIX * pixThresholdToValue ( PIX *pixd, PIX *pixs, int threshval, int setval );

$ template <class T>
$ void as_array(narray<T> &a,PIX *pix) {
$     int w = pixGetWidth(pix);
$     int h = pixGetHeight(pix);
$     int depth = pixGetDepth(pix);
$     a.resize(w,h);
$     for(int i=0;i<w;i++) for(int j=0;j<h;j++) {
$         unsigned int value = 0;
$         pixGetPixel(pix,i,h-j-1,&value);
$         if(depth==1) value *= 255;
$         else if(depth==4) value <<= 4;
$         a(i,j) = value;
$     }
$ }
$ 
$ template <class T>
$ PIX *of_array(narray<T> &a) {
$     int w = a.dim(0);
$     int h = a.dim(1);
$     PIX *result;
$     if(sizeof (T)<2) {
$         result = pixCreate(w,h,8);
$     } else {
$         result = pixCreate(w,h,32);
$     }
$     for(int i=0;i<w;i++) for(int j=0;j<h;j++) {
$         unsigned value = a(i,j);
$         pixSetPixel(result,i,h-j-1,value);
$     }
$     return result;
$ }

void as_array(bytearray &a,PIX *pix);
void as_array(intarray &a,PIX *pix);
PIX *of_array(bytearray &a);
PIX *of_array(intarray &a);

$ int pixEqualSimple(PIX *a,PIX *b) {
$     int d = 0;
$     if(pixEqual(a,b,&d)) throw "pixEqual failed";
$     return d; 
$ }
$ int pixCountPixelsSimple(PIX *a) {
$     int d = 0;
$     if(pixCountPixels(a,&d,0)) throw "pixCountPixels failed";
$     return d;
$ }

int pixEqualSimple @ pixEqual(PIX *a,PIX *b);
int pixCountPixelsSimple @ pixCountPixels(PIX *a);

$ typedef narray<rectangle> rectanglearray;
$ int pixConnCompSimple(rectanglearray &result,PIX *pixs,int connectivity) {
$     result.clear();
$     BOXA *boxes = pixConnComp(pixs,0,connectivity);
$     for(int i=0;i<boxes->n;i++) {
$         BOX *box = boxes->box[i];
$         result.push(rectangle(box->x,box->y,box->x+box->w,box->y+box->h));
$     }
$     return result.length();
$ }

int pixConnCompSimple @ pixConnComp(rectanglearray &result,PIX *pixs,int connectivity);

SEL *selCreateFromPix(PIX *pix,int cy,int cx,const char *name);
PIX *pixErode(PIX *pixd,PIX *pixs,SEL *sel);

PIX *pixDilateBrickDwa(PIX *pixd,PIX *pixs,int hsize,int vsize);
PIX *pixErodeBrickDwa(PIX *pixd,PIX *pixs,int hsize,int vsize);
PIX *pixOpenBrickDwa(PIX *pixd,PIX *pixs,int hsize,int vsize);
PIX *pixCloseBrickDwa(PIX *pixd,PIX *pixs,int hsize,int vsize);

}
